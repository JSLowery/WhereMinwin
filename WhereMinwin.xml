<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, November 04, 2016, 7:29 PM -->
<!-- MuClient version 4.98 -->

<!-- Plugin "WhereMinwin" generated by Plugin Wizard -->

<muclient>
<plugin
   name="WhereMinwin"
   author="Sonet"
   id="5fd2a99f8168d2fc74f144eb"
   language="Lua"
   purpose="Displays people in the area"
   save_state="y"
   date_written="2016-11-04 19:27:25"
   requires="4.40"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
<trigger
 match="^There are too many doors and fences to see who is in this area.$"
   regexp="y"
   send_to="12"
   sequence="1"
   group="gag_where"
    omit_from_output="y"
   script="killScript"
  >
  </trigger>
<trigger
   match="^Area created by : (.*)$"
   regexp="y"
   send_to="12"
   sequence="1"
   group="gag_where"
    omit_from_output="y"
  >
  </trigger>
  <trigger
   match="^Level range is  : (.*) to (.*)$"
   regexp="y"
   send_to="12"
   sequence="1"
   group="gag_where"
    omit_from_output="y"
  >
  </trigger>
  <trigger
   match="^You are in area\s+:\s+(.*)$"
   name="CurAreaminwin"
   regexp="y"
   send_to="12"
   sequence="1"
    omit_from_output="y"
   script="CurAreaminwin"
  >
  </trigger>
  <trigger
   match="^(?P<mob>[a-zA-Z]{3,12})\s{19,29}(?P<room>.+)$"
   
   name="DoSomething"
   regexp="y"
   send_to="12"
   sequence="1"
   omit_from_output="y"
   script="whereGrabber"
  >
  </trigger>
  <trigger
   match="^(.*?)$"
   name="KillSomething"
   regexp="y"
   send_to="12"
   sequence="1"
   omit_from_output="y"
   script="stopGrabbing"
  >
  </trigger>
  <trigger
   match="^Players near you\:$"
   regexp="y"
   send_to="12"
   sequence="100"
   omit_from_output="y"
   script="whereStarter"
   name="whereStarter"
  >
  </trigger>
  <trigger
   match="{begin running}"
   send_to="12"
   enabled="y"
   sequence="1"
   omit_from_output="n"
   script="stallScript"
   name="begrun"
  >
  
  </trigger>
  <trigger
   match="{end running}"
   send_to="12"
   enabled="y"
   sequence="1"
   omit_from_output="n"
   script="allowScript"
   name="endrun"
  >
  
  </trigger>
</triggers>
<!--  Aliases  -->

<aliases>
  <alias
   name="where1"
   match="where1"
   enabled="y"
   send_to="12"
   sequence="100"
   script="startTheScript"
  >
  </alias>
</aliases>

<!--  Timers  -->

<timers>
  <timer name="whtime" enabled="y" minute="0" second="15.00" offset_second="0.00"    send_to="12"
>
  <send>
  sendWhere1()
   DebugNote("timer ")
   </send>

  </timer>
</timers>

<!--  Script  -->


<script>
<![CDATA[
require "serialize"
require "tprint"
whereTable = {}
count = 1
local curArea= ""
local stall = false
local Debug =false
function sendWhere1()
  local iStatus
  local almatch
  local alresponse
  local alflags
  local alscriptname


  iStatus, almatch, alresponse, alflags, alscriptname  = GetAlias ("where1")
  DebugNote(alflags)
    if alflags ~=0 then 
      do_Execute_no_echo('where1')
      
    end
  end
function stallScript()
    stall = true
end
function allowScript()
  --DoAfterSpecial(1,'setStallF()', 12)
  setStallF()
  DebugNote("allow script")
  ResetTimer("whtime")
 sendWhere1()
end
function setStallF()
  stall = false
end
function CurAreaminwin(name, line, wildcards)
  curArea = wildcards[1]
  DebugNote (curArea)
end
function whereGrabber(name,line,wildcards)
    wild1 = string.lower(wildcards[1])
    DebugNote (wild1)
    DebugNote(wildcards[2].." ".. #wildcards[2])
    if wild1 == "you"  or wild1=="your"  or wild1=="the" or wild1 == "name" then killScript() return end
    --if #wildcards[2] > 40 then killScript() return end
    DebugNote (wildcards[0])
    whereTable[count] = {wildcards[1], wildcards[2]}
    DoAfterSpecial(.1 ,'stopGrabbing()', 12)
    count = count +1
end
function stopGrabbing(name,line,wildcards)
  DebugNote("stopGrabbing")
    
    show_whwin()
    killScript()
end
function DebugNote( msg )
  if not Debug then return end
    if type(msg)== 'table' then
      tprint(msg)
    else
      Note (msg)
    end
  
end
function killScript()
    EnableTrigger("DoSomething", 0)
    EnableTrigger("KillSomething", 0)
    EnableTrigger("whereStarter", 0)
    EnableTrigger("CurAreaminwin", 0)
    EnableTriggerGroup("gag_where", 0)
    stall = false
    EnableAlias("where1", 1)
end
function whereStarter()
  EnableTrigger("DoSomething", 1)
end
function startTheScript()
  if stall then DebugNote("reurtning becuase stall was true") return end
  whereTable = {}
  count = 1
  stall = true
  SendNoEcho('where')
  EnableTrigger("whereStarter", 1)
  EnableTrigger("CurAreaminwin", 1)
  EnableTriggerGroup("gag_where", 1)
  EnableAlias("where1", 0)
end
function do_Execute_no_echo(command)
  local original_echo_setting = GetOption("display_my_input")
  SetOption("display_my_input", 0)
  Execute(command)
  SetOption("display_my_input", original_echo_setting)
end
dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

-- require 'var'
-- require "commas"
require 'miniwin'
require 'pluginhelper'
-- require 'ldplugin'
-- require 'aardutils'
-- require 'verify'

whwin = Miniwin:new{name="Where Saver"}
whwin:set_default('windowpos', 7)
whwin:add_setting("time_colour", {help="the colour for the time", type="colour", default=verify_colour(0xD670DA), sortlev=1})
whwin:add_setting("mobdead_colour", {help="the colour for when a mob is dead", type="colour", default=verify_colour("red"), sortlev=1})
whwin:add_setting("mobnotfound", {help="the colour for when a mob is not in kill table db", type="colour", default=verify_colour("green"), sortlev=1})
whwin:add_setting("notlevel_colour", {help="the colour for when this cp is no longer from this level", type="colour", default=verify_colour("cyan"), sortlev=1})
--whwin:disable()

cpmobs = {}
cptimer = {}
level = nil
curlevel = nil
showwhwin = false

function set_show()
  showwhwin = true
end

function show_whwin ()

  local texttable = {}
  local header = {}
  local style = {}

  style = {}
  if curArea == nil then 
    print ("cur area == nil")
  end
  style.text = string.format("Area: %s", curArea)
  table.insert (header, {style})

  --DebugNote(whereTable)
  for i, v in ipairs (whereTable) do
    style = {}

      style.text = string.format("%-12s   %s", v[1],   v[2])
    
      style.textcolour = "time_colour"
    if v[2] == "???" then
      style.textcolour = "mobdead_colour"
    end
    table.insert (texttable, {style})

  end -- for

 

  whwin:enable()
  whwin:addtab('default', texttable, header, true)
  
    whwin:show(true)
   
  
  whwin:changetotab('default')

  style = {}
  style.text = " Area: " .. curArea
  whwin:tabbroadcast(true, {style})

end 
local runningFlag= 3
local curZone
local lastZone
function OnPluginBroadcast (msg, id, name, text)
  
    if (text== "char.status") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")
        luastmt = "gmcpdata = " .. gmcparg
        assert (loadstring (luastmt or "")) ()
        runningFlag = tonumber(gmcpdata.state)
        if runningFlag ~= 3 and runningFlag ~=8 then 
          stall = true 
        else
          stall = false
        end
    end

    if (text == "room.info") then
        res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
        luastmt = "gmcpdata = " .. gmcparg
        assert (loadstring (luastmt or "")) ()
        curZone = gmcpdata.zone
        if runningFlag ~= 3 or stall then return end
        if lastZone == nil then lastZone= curZone end
        if lastZone ~= curZone and not stall then
          lastZone = curZone
          DebugNote("OPB room.info")
          sendWhere1()
          
        end

    end
end



function OnPluginInstall ()
  --OnPluginEnable is automatically called by pluginhelper

  phelper:OnPluginInstall()
end -- OnPluginInstall

function OnPluginClose()

  phelper:OnPluginClose()
end -- OnPluginClose

function OnPluginEnable ()
 

  phelper:OnPluginEnable()
 
end -- OnPluginEnable

function OnPluginDisable ()

  phelper:OnPluginDisable()
end -- OnPluginDisable

function OnPluginConnect ()

  phelper:OnPluginConnect()
end -- OnPluginConnect

function OnPluginDisconnect ()

  phelper:OnPluginDisconnect()
end -- function OnPluginConnect

function OnPluginSaveState ()

  phelper:OnPluginSaveState()
end -- function OnPluginSaveState
phelper:set_default('cmd', 'mcp')
phelper:set_default('plugin_colour', 'steelblue')

phelper:add_pobject('win', whwin)

phelper:enable()
]]>
</script>



</muclient>
